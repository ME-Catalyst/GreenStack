"""
Node-RED Flow Generator
========================

Generates complete Node-RED flows from IODD device profiles.
Creates flows with MQTT nodes, function nodes, dashboards, and monitoring.
"""

import json
import uuid
from typing import Dict, List, Any, Optional
from dataclasses import dataclass

from src.models import DeviceProfile, Parameter, ProcessData, AccessRights


@dataclass
class NodePosition:
    """Position coordinates for Node-RED canvas"""
    x: int
    y: int


class NodeREDFlowGenerator:
    """Generate complete Node-RED flows from IODD device profiles"""

    # Node type constants
    MQTT_IN = "mqtt in"
    MQTT_OUT = "mqtt out"
    FUNCTION = "function"
    DEBUG = "debug"
    INJECT = "inject"
    CHANGE = "change"
    SWITCH = "switch"
    UI_GAUGE = "ui_gauge"
    UI_CHART = "ui_chart"
    UI_TEXT = "ui_text"
    UI_BUTTON = "ui_button"
    UI_SLIDER = "ui_slider"
    COMMENT = "comment"

    def __init__(self):
        self.node_id_counter = 0
        self.grid_x = 100
        self.grid_y = 100
        self.grid_spacing_x = 250
        self.grid_spacing_y = 100

    def generate_flow(self, profile: DeviceProfile, flow_name: Optional[str] = None) -> List[Dict[str, Any]]:
        """
        Generate a complete Node-RED flow from device profile

        Args:
            profile: DeviceProfile containing device information
            flow_name: Optional custom flow name

        Returns:
            List of Node-RED node definitions
        """
        if flow_name is None:
            flow_name = f"{profile.device_info.product_name} Monitor"

        flow_nodes = []

        # Create flow container (tab)
        flow_tab = self._create_flow_tab(flow_name, profile)
        flow_nodes.append(flow_tab)

        # Add comment header
        header_comment = self._create_comment(
            f"IO-Link Device: {profile.device_info.product_name}\n"
            f"Vendor: {profile.vendor_info.name}\n"
            f"Device ID: {profile.device_info.vendor_id}:{profile.device_info.device_id}",
            NodePosition(50, 50),
            flow_tab['id']
        )
        flow_nodes.append(header_comment)

        # Generate process data monitoring flow
        if profile.process_data.inputs or profile.process_data.outputs:
            pd_nodes = self._generate_process_data_flow(profile, flow_tab['id'])
            flow_nodes.extend(pd_nodes)

        # Generate parameter read/write flow
        if profile.parameters:
            param_nodes = self._generate_parameter_flow(profile, flow_tab['id'])
            flow_nodes.extend(param_nodes)

        # Generate dashboard UI
        dashboard_nodes = self._generate_dashboard_ui(profile, flow_tab['id'])
        flow_nodes.extend(dashboard_nodes)

        return flow_nodes

    def _create_flow_tab(self, name: str, profile: DeviceProfile) -> Dict[str, Any]:
        """Create a flow tab (container)"""
        return {
            "id": self._generate_id(),
            "type": "tab",
            "label": name,
            "disabled": False,
            "info": f"Auto-generated flow for {profile.device_info.product_name}\n"
                   f"Generated by GreenStack IODD Manager"
        }

    def _generate_process_data_flow(self, profile: DeviceProfile, flow_id: str) -> List[Dict[str, Any]]:
        """Generate nodes for process data monitoring"""
        nodes = []
        y_pos = 150

        # Comment for process data section
        comment = self._create_comment(
            "Process Data Monitoring",
            NodePosition(50, y_pos),
            flow_id
        )
        nodes.append(comment)
        y_pos += 80

        # MQTT Input for process data
        mqtt_topic = f"iolink/{profile.device_info.vendor_id}/{profile.device_info.device_id}/process_data"
        mqtt_in = self._create_mqtt_in(
            "Process Data In",
            mqtt_topic,
            NodePosition(self.grid_x, y_pos),
            flow_id
        )
        nodes.append(mqtt_in)

        # Parser function
        parser_func = self._create_function(
            "Parse Process Data",
            self._generate_process_data_parser(profile),
            NodePosition(self.grid_x + self.grid_spacing_x, y_pos),
            flow_id
        )
        nodes.append(parser_func)

        # Wire MQTT to parser
        mqtt_in['wires'] = [[parser_func['id']]]

        # Create outputs for each process data input
        for idx, pd_input in enumerate(profile.process_data.inputs):
            output_y = y_pos + (idx * 60)

            # Debug node
            debug = self._create_debug(
                f"Debug: {pd_input.name}",
                NodePosition(self.grid_x + 2 * self.grid_spacing_x, output_y),
                flow_id
            )
            nodes.append(debug)

            # Wire parser to debug
            if 'wires' not in parser_func:
                parser_func['wires'] = [[]]
            parser_func['wires'][0].append(debug['id'])

        return nodes

    def _generate_parameter_flow(self, profile: DeviceProfile, flow_id: str) -> List[Dict[str, Any]]:
        """Generate nodes for parameter read/write operations"""
        nodes = []
        y_pos = 400

        # Comment for parameters section
        comment = self._create_comment(
            "Parameter Operations",
            NodePosition(50, y_pos),
            flow_id
        )
        nodes.append(comment)
        y_pos += 80

        # Create read/write flows for writable parameters
        writable_params = [p for p in profile.parameters
                          if p.access_rights in [AccessRights.READ_WRITE, AccessRights.WRITE_ONLY]]

        for idx, param in enumerate(writable_params[:5]):  # Limit to first 5 for clarity
            param_y = y_pos + (idx * 120)

            # Inject node to trigger read
            inject_read = self._create_inject(
                f"Read {param.name}",
                NodePosition(self.grid_x, param_y),
                flow_id,
                repeat_interval=5  # Read every 5 seconds
            )
            nodes.append(inject_read)

            # Function to create read message
            read_func = self._create_function(
                f"Request {param.name}",
                self._generate_param_read_function(param),
                NodePosition(self.grid_x + self.grid_spacing_x, param_y),
                flow_id
            )
            nodes.append(read_func)

            # MQTT out to send read request
            mqtt_out_topic = f"iolink/{profile.device_info.vendor_id}/{profile.device_info.device_id}/param/read"
            mqtt_out = self._create_mqtt_out(
                "Param Read Request",
                mqtt_out_topic,
                NodePosition(self.grid_x + 2 * self.grid_spacing_x, param_y),
                flow_id
            )
            nodes.append(mqtt_out)

            # Wire inject -> function -> mqtt
            inject_read['wires'] = [[read_func['id']]]
            read_func['wires'] = [[mqtt_out['id']]]

            # If read-write, add write capability
            if param.access_rights == AccessRights.READ_WRITE:
                write_y = param_y + 60

                # Button or slider for writing
                if param.data_type.value in ['IntegerT', 'UIntegerT', 'Float32T']:
                    # Use slider for numeric values
                    ui_node = self._create_ui_slider(
                        param.name,
                        NodePosition(self.grid_x, write_y),
                        flow_id,
                        min_val=getattr(param, 'min_value', 0),
                        max_val=getattr(param, 'max_value', 100)
                    )
                else:
                    # Use button for other types
                    ui_node = self._create_ui_button(
                        f"Set {param.name}",
                        NodePosition(self.grid_x, write_y),
                        flow_id
                    )
                nodes.append(ui_node)

                # Function to create write message
                write_func = self._create_function(
                    f"Write {param.name}",
                    self._generate_param_write_function(param),
                    NodePosition(self.grid_x + self.grid_spacing_x, write_y),
                    flow_id
                )
                nodes.append(write_func)

                # MQTT out for write
                mqtt_write_topic = f"iolink/{profile.device_info.vendor_id}/{profile.device_info.device_id}/param/write"
                mqtt_write_out = self._create_mqtt_out(
                    "Param Write Request",
                    mqtt_write_topic,
                    NodePosition(self.grid_x + 2 * self.grid_spacing_x, write_y),
                    flow_id
                )
                nodes.append(mqtt_write_out)

                # Wire UI -> function -> mqtt
                ui_node['wires'] = [[write_func['id']]]
                write_func['wires'] = [[mqtt_write_out['id']]]

        return nodes

    def _generate_dashboard_ui(self, profile: DeviceProfile, flow_id: str) -> List[Dict[str, Any]]:
        """Generate dashboard UI nodes"""
        nodes = []
        y_pos = 800

        # Comment for dashboard section
        comment = self._create_comment(
            "Dashboard Visualization",
            NodePosition(50, y_pos),
            flow_id
        )
        nodes.append(comment)
        y_pos += 80

        # MQTT input for dashboard data
        mqtt_in = self._create_mqtt_in(
            "Dashboard Data",
            f"iolink/{profile.device_info.vendor_id}/{profile.device_info.device_id}/status",
            NodePosition(self.grid_x, y_pos),
            flow_id
        )
        nodes.append(mqtt_in)

        # Create gauges for numeric process data
        numeric_inputs = [pd for pd in profile.process_data.inputs
                         if pd.data_type in ['IntegerT', 'UIntegerT', 'Float32T']]

        for idx, pd_input in enumerate(numeric_inputs[:3]):  # First 3 numeric values
            gauge_y = y_pos + (idx * 100)

            gauge = self._create_ui_gauge(
                pd_input.name,
                NodePosition(self.grid_x + self.grid_spacing_x, gauge_y),
                flow_id
            )
            nodes.append(gauge)

            # Wire MQTT to gauge
            if 'wires' not in mqtt_in:
                mqtt_in['wires'] = [[]]
            mqtt_in['wires'][0].append(gauge['id'])

        # Add chart for historical data
        if numeric_inputs:
            chart_y = y_pos + 350
            chart = self._create_ui_chart(
                f"{profile.device_info.product_name} Trend",
                NodePosition(self.grid_x + self.grid_spacing_x, chart_y),
                flow_id
            )
            nodes.append(chart)
            mqtt_in['wires'][0].append(chart['id'])

        return nodes

    # Helper methods to create individual nodes

    def _create_mqtt_in(self, name: str, topic: str, pos: NodePosition, flow_id: str) -> Dict[str, Any]:
        """Create MQTT input node"""
        return {
            "id": self._generate_id(),
            "type": self.MQTT_IN,
            "z": flow_id,
            "name": name,
            "topic": topic,
            "qos": "1",
            "datatype": "json",
            "broker": "",  # To be configured by user
            "x": pos.x,
            "y": pos.y,
            "wires": [[]]
        }

    def _create_mqtt_out(self, name: str, topic: str, pos: NodePosition, flow_id: str) -> Dict[str, Any]:
        """Create MQTT output node"""
        return {
            "id": self._generate_id(),
            "type": self.MQTT_OUT,
            "z": flow_id,
            "name": name,
            "topic": topic,
            "qos": "1",
            "retain": "false",
            "broker": "",  # To be configured by user
            "x": pos.x,
            "y": pos.y,
            "wires": []
        }

    def _create_function(self, name: str, func_code: str, pos: NodePosition, flow_id: str) -> Dict[str, Any]:
        """Create function node"""
        return {
            "id": self._generate_id(),
            "type": self.FUNCTION,
            "z": flow_id,
            "name": name,
            "func": func_code,
            "outputs": 1,
            "noerr": 0,
            "x": pos.x,
            "y": pos.y,
            "wires": [[]]
        }

    def _create_debug(self, name: str, pos: NodePosition, flow_id: str) -> Dict[str, Any]:
        """Create debug node"""
        return {
            "id": self._generate_id(),
            "type": self.DEBUG,
            "z": flow_id,
            "name": name,
            "active": True,
            "tosidebar": True,
            "console": False,
            "tostatus": False,
            "complete": "payload",
            "x": pos.x,
            "y": pos.y,
            "wires": []
        }

    def _create_inject(self, name: str, pos: NodePosition, flow_id: str, repeat_interval: int = 0) -> Dict[str, Any]:
        """Create inject node"""
        node = {
            "id": self._generate_id(),
            "type": self.INJECT,
            "z": flow_id,
            "name": name,
            "props": [{"p": "payload"}],
            "repeat": str(repeat_interval) if repeat_interval > 0 else "",
            "crontab": "",
            "once": False,
            "onceDelay": 0.1,
            "topic": "",
            "payload": "",
            "payloadType": "date",
            "x": pos.x,
            "y": pos.y,
            "wires": [[]]
        }
        return node

    def _create_comment(self, text: str, pos: NodePosition, flow_id: str) -> Dict[str, Any]:
        """Create comment node"""
        return {
            "id": self._generate_id(),
            "type": self.COMMENT,
            "z": flow_id,
            "name": "",
            "info": text,
            "x": pos.x,
            "y": pos.y,
            "wires": []
        }

    def _create_ui_gauge(self, label: str, pos: NodePosition, flow_id: str) -> Dict[str, Any]:
        """Create dashboard gauge node"""
        return {
            "id": self._generate_id(),
            "type": self.UI_GAUGE,
            "z": flow_id,
            "name": label,
            "group": "",  # To be configured
            "order": 0,
            "width": "6",
            "height": "4",
            "gtype": "gage",
            "title": label,
            "label": "units",
            "format": "{{value}}",
            "min": 0,
            "max": "100",
            "colors": ["#00b500", "#e6e600", "#ca3838"],
            "seg1": "33",
            "seg2": "66",
            "x": pos.x,
            "y": pos.y,
            "wires": []
        }

    def _create_ui_chart(self, label: str, pos: NodePosition, flow_id: str) -> Dict[str, Any]:
        """Create dashboard chart node"""
        return {
            "id": self._generate_id(),
            "type": self.UI_CHART,
            "z": flow_id,
            "name": label,
            "group": "",  # To be configured
            "order": 0,
            "width": "12",
            "height": "6",
            "label": label,
            "chartType": "line",
            "legend": "true",
            "xformat": "HH:mm:ss",
            "interpolate": "linear",
            "nodata": "No data",
            "dot": False,
            "ymin": "",
            "ymax": "",
            "removeOlder": 1,
            "removeOlderPoints": "",
            "removeOlderUnit": "3600",
            "cutout": 0,
            "useOneColor": False,
            "colors": ["#1f77b4", "#aec7e8", "#ff7f0e"],
            "x": pos.x,
            "y": pos.y,
            "wires": [[]]
        }

    def _create_ui_button(self, label: str, pos: NodePosition, flow_id: str) -> Dict[str, Any]:
        """Create dashboard button node"""
        return {
            "id": self._generate_id(),
            "type": self.UI_BUTTON,
            "z": flow_id,
            "name": label,
            "group": "",  # To be configured
            "order": 0,
            "width": "3",
            "height": "1",
            "passthru": False,
            "label": label,
            "tooltip": "",
            "color": "",
            "bgcolor": "",
            "icon": "",
            "payload": "true",
            "payloadType": "bool",
            "topic": "",
            "x": pos.x,
            "y": pos.y,
            "wires": [[]]
        }

    def _create_ui_slider(self, label: str, pos: NodePosition, flow_id: str,
                         min_val: Any = 0, max_val: Any = 100) -> Dict[str, Any]:
        """Create dashboard slider node"""
        return {
            "id": self._generate_id(),
            "type": self.UI_SLIDER,
            "z": flow_id,
            "name": label,
            "label": label,
            "tooltip": "",
            "group": "",  # To be configured
            "order": 0,
            "width": "6",
            "height": "1",
            "passthru": True,
            "outs": "end",
            "topic": "",
            "min": str(min_val) if min_val is not None else "0",
            "max": str(max_val) if max_val is not None else "100",
            "step": "1",
            "x": pos.x,
            "y": pos.y,
            "wires": [[]]
        }

    def _generate_process_data_parser(self, profile: DeviceProfile) -> str:
        """Generate JavaScript function code for parsing process data"""
        func_code = """
// Parse incoming process data
const data = msg.payload;
const parsed = {};

// Extract input values
"""
        for pd_input in profile.process_data.inputs:
            func_code += f"parsed.{pd_input.id} = data.{pd_input.id} || 0;\n"

        func_code += """
msg.payload = parsed;
return msg;
"""
        return func_code

    def _generate_param_read_function(self, param: Parameter) -> str:
        """Generate JavaScript function code for parameter read"""
        return f"""
// Request parameter read
msg.payload = {{
    index: {param.index},
    subindex: {param.subindex or 0},
    name: "{param.name}"
}};
return msg;
"""

    def _generate_param_write_function(self, param: Parameter) -> str:
        """Generate JavaScript function code for parameter write"""
        return f"""
// Write parameter value
msg.payload = {{
    index: {param.index},
    subindex: {param.subindex or 0},
    name: "{param.name}",
    value: msg.payload
}};
return msg;
"""

    def _generate_id(self) -> str:
        """Generate unique node ID"""
        return str(uuid.uuid4()).replace('-', '')[:16]


def generate_monitoring_flow(profile: DeviceProfile) -> List[Dict[str, Any]]:
    """
    Generate a basic monitoring flow

    Convenience function for quick flow generation
    """
    generator = NodeREDFlowGenerator()
    return generator.generate_flow(profile, f"{profile.device_info.product_name} - Monitoring")


def generate_control_flow(profile: DeviceProfile) -> List[Dict[str, Any]]:
    """
    Generate a control flow with parameter adjustment

    Focused on writable parameters
    """
    generator = NodeREDFlowGenerator()
    flow = generator.generate_flow(profile, f"{profile.device_info.product_name} - Control")

    # Additional control-specific modifications could be added here
    return flow


__all__ = ['NodeREDFlowGenerator', 'generate_monitoring_flow', 'generate_control_flow']
